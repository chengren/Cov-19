#county = my_counties,
geometry = T,
keep_geo_vars = T)
# Fetch the ACS data
tract_data <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = states,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data2 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = states2,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data3 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = states3,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data4 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = states4,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
# Reformat the data table so that
# (1) we only keep the columns of interest - including NAME, GEOID and geometry
# (2) each estimate variable is in its own column
# ORDER MATTERS - infile must have cenvars in cenvar order!!!!
tract_data_c <- rbind(tract_data,tract_data1,tract_data2,tract_data3,tract_data4)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'HI',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'ID',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'IN',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'IA',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'KS',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'KY',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'LA',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'ME',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'MD',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI', 'ID', 'IL', 'IN', 'IA')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = state1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','ID', 'IL', 'IN','KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','ID', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','ID','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states <- c('AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'DC', 'FL', 'GA')
states1<- c('HI','ID','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
states2 <- c('MA', 'MI',  'MN', 'MS', 'MO', 'MT', 'NE', 'NV')
states3 <- c('NJ', 'NM', 'NY', 'NC', 'ND','OH', 'OK', 'OR', 'PA')
states4 <- c('PR','RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA','WA', 'WV', 'WI', 'WY')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IL','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IN','IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data5 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = c('ID','IL','IN'),
#county = my_counties,
geometry = T,
keep_geo_vars = T)# do not know why 'ID'/ILis different from others
tract_data5 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = c('ID','IL'),
#county = my_counties,
geometry = T,
keep_geo_vars = T)# do not know why 'ID'/ILis different from others
tract_data6 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = c('IN'),
#county = my_counties,
geometry = T,
keep_geo_vars = T)#
# Fetch the ACS data
tract_data <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data2 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states2,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data3 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states3,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data4 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states4,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
View(tract_data6)
# Reformat the data table so that
# (1) we only keep the columns of interest - including NAME, GEOID and geometry
# (2) each estimate variable is in its own column
# ORDER MATTERS - infile must have cenvars in cenvar order!!!!
tract_data_c <- rbind(tract_data,tract_data1,
tract_data2,tract_data3,
tract_data4,tract_data5,
tract_data6)
tract_data_c1 <- tract_data_c %>%
select("NAME.y","GEOID","ALAND","variable","estimate") %>%
spread(key=variable, value=estimate)
#Remove rows with no land are
tract_data_c1  <- tract_data_c1 [!is.na(tract_data_c1 $ALAND),]
View(tract_data_c1)
# Copy for debugging
tract_data_c2 <- tract_data_c1
# rename columns
colnames(tract_data_c2) <- c("NAME","GEOID", "land_area", my_cenvar_df$my_cen_var_names, "geometry")
# Remove rows with no people
tract_data_c2 <- tract_data_c2[tract_data_c2$tract_totpop!=0,]
# Copy for debugging
tract_data_c2 <- tract_data_c1
# rename columns
colnames(tract_data_c2) <- c("NAME","GEOID", "land_area", my_cenvar_df$my_cen_var_names, "geometry")
View(tract_data_c2)
# Remove rows with no people
tract_data_c2 <- tract_data_c2[tract_data_c2$tract_totpop!=0,]
View(tract_data_c2)
View(tract_data_c1)
# Copy for debugging
tract_data_c2 <- tract_data_c1
# rename columns
colnames(tract_data_c2) <- c("NAME","GEOID", "land_area","geometry",my_cenvar_df$my_cen_var_names)
# Remove rows with no people
tract_data_c2 <- tract_data_c2[tract_data_c2$tract_totpop!=0,]
# Change units for land_area from sq meters to sq km
tract_data_c2$p_land_areakm2 <- tract_data_c2$land_area / (1000 * 1000)
tract_data_c2$p_land_acreage <- tract_data_c2$land_area / 4046.856
tract_data_c2$p_land_sqmiles <- tract_data_c2$land_area / 2589988.1103
#tfix <- tract_data2[tract_data2$GEOID == "06041122000",]
# Create Calculated columns
## Note: keeping colnames short due to shapefile limits
tract_data_c3 <- tract_data_c2 %>%
mutate (
# Immigrant noncitizens in the total pop
p_noncit_totpop = tract_totpop,
p_noncit_count = tract_fborn_noncit,
p_noncit = ifelse(tract_totpop==0, 0, round(100 * (tract_fborn_noncit/tract_totpop),1)),
p_noncit_density = ifelse(tract_totpop==0, 0, round((tract_fborn_noncit / p_land_sqmiles),1)),
# Immigrants in the total pop
p_fborn_totpop = tract_totpop,
p_fborn_count = tract_fborn,
p_fborn =   ifelse(tract_totpop==0, 0, round(100 * (tract_fborn / tract_totpop), 1)),
p_fborn_density =  ifelse(tract_totpop==0, 0, round((tract_fborn / p_land_sqmiles),1)),
# Recent Immigrants in the total pop
p_recent_totpop = tract_totpop,
p_recent_count = tract_post2010_fborn,
p_recent =  ifelse(tract_totpop==0, 0, round(100 * (tract_post2010_fborn / tract_totpop),1)),
p_recent_density = ifelse(tract_totpop==0, 0, round((tract_post2010_fborn / p_land_sqmiles),1)),
# Immigrants living 150% below poverty in the Population for whom poverty has been determined
p_fb_pov_totpop = poverty_totpop,
p_fb_pov_count = (poverty_100below_fborn + poverty_100to149below_fborn),
p_fb_pov =  ifelse(poverty_totpop==0, 0, round(100 * ((poverty_100below_fborn + poverty_100to149below_fborn) / poverty_totpop),1)),
p_fb_pov_density =  ifelse(poverty_totpop==0, 0, round( ((poverty_100below_fborn + poverty_100to149below_fborn) / p_land_sqmiles),1)),
# Immigrants with no health insurance in the Civilian Noninstitutionalized Population
p_fb_nohi_totpop = nohealth_totpop,
p_fb_nohi_count = (nohealth_fborn_nat + nohealth_fborn_noncit),
p_fb_nohi = ifelse(nohealth_totpop==0, 0, round(100 * (nohealth_fborn_nat + nohealth_fborn_noncit) / nohealth_totpop,1)),
p_fb_nohi_density = ifelse(nohealth_totpop==0, 0, round(((nohealth_fborn_nat + nohealth_fborn_noncit) / p_land_sqmiles),1)),
#
p_fb_noncit_nohi_totpop = nohealth_totpop,
p_fb_noncit_nohi_count = nohealth_fborn_noncit,
p_fb_noncit_nohi = ifelse(nohealth_totpop==0, 0, round(100 * (nohealth_fborn_noncit / nohealth_totpop),1)),
p_fb_noncit_nohi_density =  ifelse(nohealth_totpop==0, 0, round((nohealth_fborn_noncit / p_land_sqmiles),1)),
# Limited english speakers by language spoken at home in the population over 5
# limited_english_totpop variable is the denominator
p_lim_eng_totpop = limited_english_totpop,
#spanish
p_lim_eng_spanish_count = limited_english_spanish,
p_lim_eng_spanish = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_spanish / limited_english_totpop),1)),
p_lim_eng_spanish_density = ifelse(limited_english_totpop==0, 0, round((limited_english_spanish / p_land_sqmiles),1)),
#chinese
p_lim_eng_chinese_count = limited_english_chinese,
p_lim_eng_chinese = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_chinese / limited_english_totpop),1)),
p_lim_eng_chinese_density = ifelse(limited_english_totpop==0, 0, round((limited_english_chinese / p_land_sqmiles),1)),
#tagalog
p_lim_eng_tagalog_count = limited_english_tagalog,
p_lim_eng_tagalog = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_tagalog / limited_english_totpop),1)),
p_lim_eng_tagalog_density = ifelse(limited_english_totpop==0, 0, round((limited_english_tagalog / p_land_sqmiles),1)),
#vitenamese
p_lim_eng_vietnamese_count = limited_english_vietnamese,
p_lim_eng_vietnamese = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_vietnamese / limited_english_totpop),1)),
p_lim_eng_vietnamese_density = ifelse(limited_english_totpop==0, 0, round((limited_english_vietnamese / p_land_sqmiles),1)),
#korean
p_lim_eng_korean_count = limited_english_korean,
p_lim_eng_korean = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_korean / limited_english_totpop),1)),
p_lim_eng_korean_density = ifelse(limited_english_totpop==0, 0, round((limited_english_korean / p_land_sqmiles),1)),
#other - needed for determining quantile bins only
p_lim_eng_allgroups_count = (limited_english_spanish + limited_english_chinese + limited_english_tagalog +
limited_english_vietnamese + limited_english_korean +
limited_english_french +  limited_english_german + limited_english_russian +
limited_english_other_indoeuropean +  limited_english_other_api +
limited_english_arabic +  limited_english_other),
p_lim_eng_allgroups = ifelse(limited_english_totpop==0, 0, round(100 * (p_lim_eng_allgroups_count / limited_english_totpop),1))
)
# Transforming CRS from NAD83 to WGS84 ("+proj=longlat +datum=WGS84")
tract_data_c3 <- st_transform(tract_data_c3, 4326)
# WRITE output to CSV
write_sf(tract_data_c3,"msi_tractdata_acs2017.csv", layer_options = "GEOMETRY=AS_WKT", delete_layer=TRUE, delete_dsn=TRUE)
# Save vars to be mapped only
census_data <- select(tract_data_c3, "NAME", "GEOID", starts_with("p_"))
# Save vars to be mapped only
census_data <- select(tract_data_c3, "NAME", "GEOID", starts_with("p_"))
# WRITE output to CSV
write_sf(tract_data_c3,"msi_tractdata_acs2018.csv", layer_options = "GEOMETRY=AS_WKT", delete_layer=TRUE, delete_dsn=TRUE)
# WRITE output to CSV
write_sf(tract_data_c3,"msi_tractdata_acs2018.csv", layer_options = "GEOMETRY=AS_WKT", delete_layer=TRUE, delete_dsn=TRUE)
# Save vars to be mapped only
census_data <- select(tract_data_c3, "NAME", "GEOID", starts_with("p_"))
View(census_data)
# Remove temp objects
keep_objects <- c("census_data")
rm(list = setdiff(ls(), keep_objects))
# Write Census Data to an Rdata file (census)
save.image("census_tract_data_processed.Rdata")
# remove objects from session
rm(list = ls())
library(dplyr)
library(tidyr)
library(sf)
library(readxl)
library(tools)
setwd("/Users/chengren/Documents/GitHub/Cov-19/")
# Source code to jitter any duplicate coords (locations)
source("0_geoR_jitter.R")
setwd("/Users/chengren/Documents/GitHub/Cov-19/Data_input")
df <- read.csv('Hospitals.csv')
# only for migrant
#df_mg <- df%>%filter(Migrant.Health.Centers.HRSA.Grant.Subprogram.Indicator == "Y")
hospitals <- df
hospitals$id <- 1:nrow(hospitals)
hospitals$NAME <-  toTitleCase(tolower(as.character(hospitals$NAME)))
hospitals$TYPE <-  toTitleCase(tolower(as.character(hospitals$TYPE)))
hospitals[c("X","Y")] <- jitterDupCoords(hospitals[c("X","Y")],min=0.00001, max=0.00009)
hospitals$ADDRESS<-  toTitleCase(tolower(as.character(hospitals$ADDRESS)))
hospitals$CITY<-  toTitleCase(tolower(as.character(hospitals$CITY)))
hospitals$full_address <- paste0(hospitals$ADDRESS, ", ",
hospitals$CITY, ", ",
hospitals$STATE, " ",
hospitals$ZIP)
hospitals$full_address<-  toTitleCase(as.character(hospitals$full_address))
###################################
# Reformat to create website URL
####################################
hospitals$website <- hospitals$WEBSITE
hospitals$website <- gsub('None|NA|N/A|NOT AVAILABLE','',hospitals$website)
hospitals$website <- ifelse(substring(hospitals$website, 1, 4) == "http"|
hospitals$website=="",
hospitals$website, paste0("http://", hospitals$website))
###################################
# telephone
####################################
hospitals$telephone <- hospitals$TELEPHONE
hospitals$telephone <- gsub('None|NA|N/A|NOT AVAILABLE','',hospitals$telephone)
###################################
# Format Zip Codes
#####################################
hospitals$zipcode <- substr(hospitals$ZIP, 1, 5)
health_keep_cols <- c(
"id",                      # need a unique id
"NAME",
"full_address",
"telephone",
#"Federally.Qualified.Health.Center.FQHC.Look.Alike.Organization.Site.Administrator.Contact.Email.Address",
"website",
#"Mission.Statement",
"X",
"Y",
#"health_services",
#"language_filter",
#"service_access",
#"Site.City",
"zipcode",
# "Migrant.Health.Centers.HRSA.Grant.Subprogram.Indicator",
# "Serving.Uninsured",
# "Capacity.Hours.of.Operation.per.Week"
"BEDS",
"TYPE"
)
hospitals <- hospitals[c(health_keep_cols)]
# Rename the columns
colnames(hospitals) <- c("ID", "org", "address", "phone", "website", #"mission",
"lon", "lat", #"services", "language_support", "service_access", #"city",
"zipcode","beds_capacity","type"
#"HRSA", "uninsured", "capacity_hours"
)
round(colSums(is.na(hospitals))/nrow(hospitals)*100,2)
#drop lon is NA
hospitals <- hospitals[!is.na(hospitals$lon), ]
round(colSums(is.na(hospitals))/nrow(hospitals)*100,2)
#write out
setwd("/Users/chengren/Documents/GitHub/Cov-19/Data_output")
write.csv(hospitals,"3_hospitals_national.csv",row.names = FALSE)
