#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data4 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = states4,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
# Reformat the data table so that
# (1) we only keep the columns of interest - including NAME, GEOID and geometry
# (2) each estimate variable is in its own column
# ORDER MATTERS - infile must have cenvars in cenvar order!!!!
tract_data_c <- rbind(tract_data,tract_data1,tract_data2,tract_data3,tract_data4)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'HI',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'ID',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'IN',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'IA',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'KS',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'KY',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'LA',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'ME',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
#note one state do not have 2018 data in tract_data1
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2017,
survey="acs5",
state = 'MD',
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI', 'ID', 'IL', 'IN', 'IA')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = state1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','ID', 'IL', 'IN','KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','ID', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','ID','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states <- c('AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'DC', 'FL', 'GA')
states1<- c('HI','ID','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
states2 <- c('MA', 'MI',  'MN', 'MS', 'MO', 'MT', 'NE', 'NV')
states3 <- c('NJ', 'NM', 'NY', 'NC', 'ND','OH', 'OK', 'OR', 'PA')
states4 <- c('PR','RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA','WA', 'WV', 'WI', 'WY')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IL','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IN','IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
states1<- c('HI','IA', 'KS', 'KY', 'LA', 'ME', 'MD')
tract_data1 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states1,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data5 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = c('ID','IL','IN'),
#county = my_counties,
geometry = T,
keep_geo_vars = T)# do not know why 'ID'/ILis different from others
tract_data5 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = c('ID','IL'),
#county = my_counties,
geometry = T,
keep_geo_vars = T)# do not know why 'ID'/ILis different from others
tract_data6 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = c('IN'),
#county = my_counties,
geometry = T,
keep_geo_vars = T)#
# Fetch the ACS data
tract_data <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data2 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states2,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data3 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states3,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
tract_data4 <- get_acs(geography = "tract",
variables = my_cenvar_df$my_cen_vars,
year=2018,
survey="acs5",
state = states4,
#county = my_counties,
geometry = T,
keep_geo_vars = T)
View(tract_data6)
# Reformat the data table so that
# (1) we only keep the columns of interest - including NAME, GEOID and geometry
# (2) each estimate variable is in its own column
# ORDER MATTERS - infile must have cenvars in cenvar order!!!!
tract_data_c <- rbind(tract_data,tract_data1,
tract_data2,tract_data3,
tract_data4,tract_data5,
tract_data6)
tract_data_c1 <- tract_data_c %>%
select("NAME.y","GEOID","ALAND","variable","estimate") %>%
spread(key=variable, value=estimate)
#Remove rows with no land are
tract_data_c1  <- tract_data_c1 [!is.na(tract_data_c1 $ALAND),]
View(tract_data_c1)
# Copy for debugging
tract_data_c2 <- tract_data_c1
# rename columns
colnames(tract_data_c2) <- c("NAME","GEOID", "land_area", my_cenvar_df$my_cen_var_names, "geometry")
# Remove rows with no people
tract_data_c2 <- tract_data_c2[tract_data_c2$tract_totpop!=0,]
# Copy for debugging
tract_data_c2 <- tract_data_c1
# rename columns
colnames(tract_data_c2) <- c("NAME","GEOID", "land_area", my_cenvar_df$my_cen_var_names, "geometry")
View(tract_data_c2)
# Remove rows with no people
tract_data_c2 <- tract_data_c2[tract_data_c2$tract_totpop!=0,]
View(tract_data_c2)
View(tract_data_c1)
# Copy for debugging
tract_data_c2 <- tract_data_c1
# rename columns
colnames(tract_data_c2) <- c("NAME","GEOID", "land_area","geometry",my_cenvar_df$my_cen_var_names)
# Remove rows with no people
tract_data_c2 <- tract_data_c2[tract_data_c2$tract_totpop!=0,]
# Change units for land_area from sq meters to sq km
tract_data_c2$p_land_areakm2 <- tract_data_c2$land_area / (1000 * 1000)
tract_data_c2$p_land_acreage <- tract_data_c2$land_area / 4046.856
tract_data_c2$p_land_sqmiles <- tract_data_c2$land_area / 2589988.1103
#tfix <- tract_data2[tract_data2$GEOID == "06041122000",]
# Create Calculated columns
## Note: keeping colnames short due to shapefile limits
tract_data_c3 <- tract_data_c2 %>%
mutate (
# Immigrant noncitizens in the total pop
p_noncit_totpop = tract_totpop,
p_noncit_count = tract_fborn_noncit,
p_noncit = ifelse(tract_totpop==0, 0, round(100 * (tract_fborn_noncit/tract_totpop),1)),
p_noncit_density = ifelse(tract_totpop==0, 0, round((tract_fborn_noncit / p_land_sqmiles),1)),
# Immigrants in the total pop
p_fborn_totpop = tract_totpop,
p_fborn_count = tract_fborn,
p_fborn =   ifelse(tract_totpop==0, 0, round(100 * (tract_fborn / tract_totpop), 1)),
p_fborn_density =  ifelse(tract_totpop==0, 0, round((tract_fborn / p_land_sqmiles),1)),
# Recent Immigrants in the total pop
p_recent_totpop = tract_totpop,
p_recent_count = tract_post2010_fborn,
p_recent =  ifelse(tract_totpop==0, 0, round(100 * (tract_post2010_fborn / tract_totpop),1)),
p_recent_density = ifelse(tract_totpop==0, 0, round((tract_post2010_fborn / p_land_sqmiles),1)),
# Immigrants living 150% below poverty in the Population for whom poverty has been determined
p_fb_pov_totpop = poverty_totpop,
p_fb_pov_count = (poverty_100below_fborn + poverty_100to149below_fborn),
p_fb_pov =  ifelse(poverty_totpop==0, 0, round(100 * ((poverty_100below_fborn + poverty_100to149below_fborn) / poverty_totpop),1)),
p_fb_pov_density =  ifelse(poverty_totpop==0, 0, round( ((poverty_100below_fborn + poverty_100to149below_fborn) / p_land_sqmiles),1)),
# Immigrants with no health insurance in the Civilian Noninstitutionalized Population
p_fb_nohi_totpop = nohealth_totpop,
p_fb_nohi_count = (nohealth_fborn_nat + nohealth_fborn_noncit),
p_fb_nohi = ifelse(nohealth_totpop==0, 0, round(100 * (nohealth_fborn_nat + nohealth_fborn_noncit) / nohealth_totpop,1)),
p_fb_nohi_density = ifelse(nohealth_totpop==0, 0, round(((nohealth_fborn_nat + nohealth_fborn_noncit) / p_land_sqmiles),1)),
#
p_fb_noncit_nohi_totpop = nohealth_totpop,
p_fb_noncit_nohi_count = nohealth_fborn_noncit,
p_fb_noncit_nohi = ifelse(nohealth_totpop==0, 0, round(100 * (nohealth_fborn_noncit / nohealth_totpop),1)),
p_fb_noncit_nohi_density =  ifelse(nohealth_totpop==0, 0, round((nohealth_fborn_noncit / p_land_sqmiles),1)),
# Limited english speakers by language spoken at home in the population over 5
# limited_english_totpop variable is the denominator
p_lim_eng_totpop = limited_english_totpop,
#spanish
p_lim_eng_spanish_count = limited_english_spanish,
p_lim_eng_spanish = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_spanish / limited_english_totpop),1)),
p_lim_eng_spanish_density = ifelse(limited_english_totpop==0, 0, round((limited_english_spanish / p_land_sqmiles),1)),
#chinese
p_lim_eng_chinese_count = limited_english_chinese,
p_lim_eng_chinese = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_chinese / limited_english_totpop),1)),
p_lim_eng_chinese_density = ifelse(limited_english_totpop==0, 0, round((limited_english_chinese / p_land_sqmiles),1)),
#tagalog
p_lim_eng_tagalog_count = limited_english_tagalog,
p_lim_eng_tagalog = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_tagalog / limited_english_totpop),1)),
p_lim_eng_tagalog_density = ifelse(limited_english_totpop==0, 0, round((limited_english_tagalog / p_land_sqmiles),1)),
#vitenamese
p_lim_eng_vietnamese_count = limited_english_vietnamese,
p_lim_eng_vietnamese = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_vietnamese / limited_english_totpop),1)),
p_lim_eng_vietnamese_density = ifelse(limited_english_totpop==0, 0, round((limited_english_vietnamese / p_land_sqmiles),1)),
#korean
p_lim_eng_korean_count = limited_english_korean,
p_lim_eng_korean = ifelse(limited_english_totpop==0, 0, round(100 * (limited_english_korean / limited_english_totpop),1)),
p_lim_eng_korean_density = ifelse(limited_english_totpop==0, 0, round((limited_english_korean / p_land_sqmiles),1)),
#other - needed for determining quantile bins only
p_lim_eng_allgroups_count = (limited_english_spanish + limited_english_chinese + limited_english_tagalog +
limited_english_vietnamese + limited_english_korean +
limited_english_french +  limited_english_german + limited_english_russian +
limited_english_other_indoeuropean +  limited_english_other_api +
limited_english_arabic +  limited_english_other),
p_lim_eng_allgroups = ifelse(limited_english_totpop==0, 0, round(100 * (p_lim_eng_allgroups_count / limited_english_totpop),1))
)
# Transforming CRS from NAD83 to WGS84 ("+proj=longlat +datum=WGS84")
tract_data_c3 <- st_transform(tract_data_c3, 4326)
# WRITE output to CSV
write_sf(tract_data_c3,"msi_tractdata_acs2017.csv", layer_options = "GEOMETRY=AS_WKT", delete_layer=TRUE, delete_dsn=TRUE)
# Save vars to be mapped only
census_data <- select(tract_data_c3, "NAME", "GEOID", starts_with("p_"))
# Save vars to be mapped only
census_data <- select(tract_data_c3, "NAME", "GEOID", starts_with("p_"))
# WRITE output to CSV
write_sf(tract_data_c3,"msi_tractdata_acs2018.csv", layer_options = "GEOMETRY=AS_WKT", delete_layer=TRUE, delete_dsn=TRUE)
# WRITE output to CSV
write_sf(tract_data_c3,"msi_tractdata_acs2018.csv", layer_options = "GEOMETRY=AS_WKT", delete_layer=TRUE, delete_dsn=TRUE)
# Save vars to be mapped only
census_data <- select(tract_data_c3, "NAME", "GEOID", starts_with("p_"))
View(census_data)
# Remove temp objects
keep_objects <- c("census_data")
rm(list = setdiff(ls(), keep_objects))
# Write Census Data to an Rdata file (census)
save.image("census_tract_data_processed.Rdata")
# remove objects from session
rm(list = ls())
library(dplyr)
library(tidyr)
library(sf)
library(readxl)
setwd("/Users/chengren/Documents/GitHub/Cov-19/")
# Source code to jitter any duplicate coords (locations)
source("0_geoR_jitter.R")
setwd("/Users/chengren/Documents/GitHub/Cov-19/data_input")
df <- read.csv('hosptial.csv')
setwd("/Users/chengren/Documents/GitHub/Cov-19/Data_input")
df <- read.csv('hosptial.csv')
df <- read.csv('Hosptial.csv')
df <- read.csv('Hospital.csv')
dir()
df <- read.csv('Hospitals.csv')
library(stringr)
library(dplyr)
library(tidyr)
library(sf)
library(readxl)
library(stringr)
setwd("/Users/chengren/Documents/GitHub/Cov-19")
# Source code to jitter any duplicate coords (locations)
source("geoR_jitter.R")
setwd("/Users/chengren/Documents/GitHub/Cov-19/Data_input")
df <- read.csv('SITE_HCC_FCT_DET.csv')
# only for migrant
#df_mg <- df%>%filter(Migrant.Health.Centers.HRSA.Grant.Subprogram.Indicator == "Y")
health_clinics <- df
View(health_clinics)
health_clinics$ID <- 1:nrow(health_clinics)
library(dplyr)
library(tidyr)
library(sf)
library(readxl)
library(stringr)
setwd("/Users/chengren/Documents/GitHub/Cov-19")
# Source code to jitter any duplicate coords (locations)
source("geoR_jitter.R")
setwd("/Users/chengren/Documents/GitHub/Cov-19/Data_input")
df <- read.csv('SITE_HCC_FCT_DET.csv')
# only for migrant
#df_mg <- df%>%filter(Migrant.Health.Centers.HRSA.Grant.Subprogram.Indicator == "Y")
health_clinics <- df
health_clinics$ID <- 1:nrow(health_clinics)
health_clinics$Site.Name <- titleCase(health_clinics$Site.Name )
colnames(health_clinics) <- gsub("\\.\\.\\.\\.|\\.\\.", ".", colnames(health_clinics))
health_clinics[c("Geocoding.Artifact.Address.Primary.X.Coordinate","Geocoding.Artifact.Address.Primary.Y.Coordinate")] <- jitterDupCoords(health_clinics[c("Geocoding.Artifact.Address.Primary.X.Coordinate",
"Geocoding.Artifact.Address.Primary.Y.Coordinate")],
min=0.00001, max=0.00009)
health_clinics$full_address <- paste0(health_clinics$Site.Address, ", ",
health_clinics$Site.City, ", ",
health_clinics$Site.State.Abbreviation, " ",
health_clinics$Site.Postal.Code)
###################################
# Reformat to create website URL
####################################
health_clinics$website <- health_clinics$Site.Web.Address
health_clinics$website <- gsub('None|NA|N/A','',health_clinics$website)
health_clinics$website <- ifelse(substring(health_clinics$website, 1, 4) == "http"|
health_clinics$website=="",
health_clinics$website, paste0("http://", health_clinics$website))
# Format Zip Codes
health_clinics$zipcode <- substr(health_clinics$Site.Postal.Code, 1, 5)
#get county code
table(health_clinics$County.or.County.Equivalent.Federal.Information.Processing.Standard.Code)
health_keep_cols <- c(
"ID",                      # need a unique id
"Site.Name",
"full_address",
"Site.Telephone.Number",
"Federally.Qualified.Health.Center.FQHC.Look.Alike.Organization.Site.Administrator.Contact.Email.Address",
"website",
#"Mission.Statement",
"Geocoding.Artifact.Address.Primary.X.Coordinate",
"Geocoding.Artifact.Address.Primary.Y.Coordinate",
#"health_services",
#"language_filter",
#"service_access",
#"Site.City",
"zipcode"#,
# "Migrant.Health.Centers.HRSA.Grant.Subprogram.Indicator",
# "Serving.Uninsured",
# "Capacity.Hours.of.Operation.per.Week"
)
health_clinics <- health_clinics[c(health_keep_cols)]
# Rename the columns
colnames(health_clinics) <- c("ID", "org", "address", "phone", "email", "website", #"mission",
"lon", "lat", #"services", "language_support", "service_access", #"city",
"zipcode"#,
#"HRSA", "uninsured", "capacity_hours"
)
round(colSums(is.na(health_clinics))/nrow(health_clinics)*100,2)
#drop lon is NA
health_clinics <- health_clinics[!is.na(health_clinics$lon), ]
round(colSums(is.na(health_clinics))/nrow(health_clinics)*100,2)
clinics_preload <- health_clinics
clinics_preload$type <- "health"
#write out
setwd("/Users/chengren/Documents/GitHub/Cov-19/Data_output")
write.csv(health_clinics,"health_clinics_national.csv",row.names = FALSE)
library(dplyr)
library(tidyr)
library(sf)
library(readxl)
setwd("/Users/chengren/Documents/GitHub/Cov-19/")
# Source code to jitter any duplicate coords (locations)
source("0_geoR_jitter.R")
setwd("/Users/chengren/Documents/GitHub/Cov-19/Data_input")
df <- read.csv('Hospitals.csv')
